%% 2023 MJ, Time-delay analysis of OTS2
% It uses the tacking data generated by ImageJ TrackMate

%% Note
% 230317 vertorized the loops for filterin to speedup
% 230317 xml file loading was improved. see LoadTrackMateTracksMJv1
% ++ add median filter?
% ++ confirm the frame offset. trackmate may start from 0...


%% Preparation
%clear all
clearvars -except tracks1 tracks2 info1 info2 trjfile1 trjfile2 imagefile pathImgFile
close all
PTS2anaStart = tic;

%% Settings for analysis
path0 = 'E:\OneDrive - Johns Hopkins\MJ\ExpData\ExpData_Cell_2023';
%path0 = 'E:\OneDrive - Johns Hopkins\MJ\MJ_WeeklyReports_HaLab\OTS\data_U2OSpg_L15g2';

fTest = false;                  % skip data loading and save
RICMchannel=1;
nChan = 4;                      % check the number of channel!!!
frameToOverlay = 40;            % use 0 NOT TO USE %OverlayOnImageFrame = [40 4];   % [frame nChan], use [0 n] NOT TO USE
TimeDelayFitting = 15;          % use n delay frames for curve fitting, "0" not to use.
imgsize=800; edge=100;          %set ROI to be pairing analyzed
frameCnt = 200;                       %the number of frames
roi = [edge imgsize-edge edge imgsize-edge];

criInter = 0.6;                 %for colocalization
criIntra = 0.5;                 %for blinking correction
criOverlap = 2.5;                 %remove overlapping spots
interval = 15;                  % interval:(nf-interval) for g, 2:(nf-interval) for red
lateralOffset = [0.0, 0.0];     %manual chromatic error correction // use corrected image!
criLengthMin1 = 2;              %filter out too short trajectories
criLengthMin2 = 3;              %filter out too short trajectories
timeHistEdges = (-35.5:1:35.5);


%% Import the tracking results [ Ti, Xi, Yi, Zi ; ...]
cd(path0);
if ~fTest
    [imagefile,pathImgFile] = uigetfile('*.tif','Open an image file to overlay');
    cd(pathImgFile)
    [filepath,filenamehead,ext] = fileparts(imagefile);
    trjfile1 = [filenamehead '_g.xml'];
    trjfile2 = [filenamehead '_r.xml'];
    path=pathImgFile;

    if ~isfile(trjfile1) || ~isfile(trjfile2) %|| ~frameToOverlay
        [trjfile1,pathTracks,indx1] = uigetfile('*.xml', 'Choose a reference track file (high force)');
        [trjfile2,pathTracks,indx2] = uigetfile('*.xml', 'Choose a track file to be compared (low force)');
        cd(pathTracks);
        path=pathTracks;
    end

    disp('Loading TrackMate xml files...')
    tic
    % 'importTrackMateTracks' is replaced. it was very slow.
    [tracks1, info1] = LoadTrackMateTracksMJv1(trjfile1);
    [tracks2, info2] = LoadTrackMateTracksMJv1(trjfile2);
    toc
end
cnt1 = size(tracks1,1);
disp([num2str(cnt1) ' spots are loaded (reference)'])
cnt2 = size(tracks2,1);
disp([num2str(cnt2) ' spots are loaded (to compare)'])
spaceUnit = info1.spaceUnits
timeUnit = info1.timeUnits
frameInterval = info1.frameInterval
disp('round frameInterval')
frameInterval = round(frameInterval, 2)

%% Filter out: length


%% Collect the spot location + filter out too short trajectories
first1 = nan(cnt1,3);
for i=1:cnt1
    if size(tracks1{i},1) >= criLengthMin1
        first1(i,1) = tracks1{i}(1,1);  %first appearance
        first1(i,2) = mean(tracks1{i}(:,2));  %x
        first1(i,3) = mean(tracks1{i}(:,3));  %y
    end
end

first2 = nan(cnt2,3);
for i=1:cnt2
    if size(tracks2{i},1) >= criLengthMin2
        %first2(i,:) = tracks2{i}(1,1:3);
        first2(i,1) = tracks2{i}(1,1);  %first appearance
        first2(i,2) = median(tracks2{i}(:,2));  %x
        first2(i,3) = median(tracks2{i}(:,3));  %y
    end
end


%% Filter out : region and frame of interest
disp( [ 'spots (ch1, ch2): ' num2str(nnz(~isnan(first1(:,1)))) ', ' ...
    num2str(nnz(~isnan(first2(:,1)))) ])
disp('Spots only in ROI & FOI')
for i=1:cnt1
    if (first1(i,1) < interval) || (first1(i,1) > frameCnt-interval)
        first1(i,:)=[nan, nan, nan];
    end

    if (first1(i,2) < roi(1)) || (first1(i,3) < roi(3)) || ...
            (first1(i,2) > roi(2)) || (first1(i,3) > roi(4))
        first1(i,:)=[nan, nan, nan];
    end

end
for i=1:cnt2
    if (first2(i,1) < 2 || (first2(i,1) > frameCnt-interval) )
        first2(i,:)=[nan, nan, nan];
    end

    if (first2(i,2) < roi(1)) || (first2(i,3) < roi(3)) || ...
            (first2(i,2) > roi(2)) || (first2(i,3) > roi(4))
        first2(i,:)=[nan, nan, nan];
    end
end

%% Filter out : already activated spots and spot very near edges
disp( [ 'spots (ch1, ch2): ' num2str(nnz(~isnan(first1(:,1)))) ', ' ...
    num2str(nnz(~isnan(first2(:,1)))) ])
disp('Filter out already, early activated spots.')
for i=1:cnt1
    if (first1(i,1) < interval) %% || (first1(i,1) > size-interval)
        first1(i,:)=[nan, nan, nan];
    end
end
for i=1:cnt2
    if (first2(i,1) < 1)
        first2(i,:)=[nan, nan, nan];
    end
end
disp( [ 'spots (ch1, ch2): ' num2str(nnz(~isnan(first1(:,1)))) ', ' ...
    num2str(nnz(~isnan(first2(:,1)))) ])

%% Filter out the revived spots (blinking etc.) ***Use the vectorized version to speed up.
disp('Filter out revived spots')

% Compute distance matrix
distanceMatrix = pdist2(first1(:,2:3), first1(:,2:3)); 
% Find pairs of rows within criIntra
[i,j] = find(tril(distanceMatrix < criIntra & distanceMatrix ~= 0));
% Find indices of rows to remove
remove_idx = (first1(i,1) - first1(j,1)) >= 0; 
% Remove rows
first1(i(remove_idx),:) = NaN;

% Repreat for "first2"
distanceMatrix = pdist2(first2(:,2:3), first2(:,2:3)); 
[i,j] = find(tril(distanceMatrix < criIntra & distanceMatrix ~= 0)); 
remove_idx = (first2(i,1) - first2(j,1)) >= 0; 
first2(i(remove_idx),:) = NaN;

% for i=1:cnt1-1
%     for j=i+1:cnt1
%         displace = first1(i,:) - first1(j,:);
%         distance = sqrt(displace(2)^2 + displace(3)^2);
%         if distance < criIntra
%             if (first1(j,1)-first1(i,1))>=0
%                 first1(j,:)=[nan, nan, nan];
%             else
%                 first1(i,:)=[nan, nan, nan];
%             end
%         end
%     end
% end
% for i=1:cnt2-1
%     for j=i+1:cnt2
%         displace = first2(i,:) - first2(j,:);
%         distance = sqrt(displace(2)^2 + displace(3)^2);
%         if distance < criIntra
%             if (first2(j,1)-first2(i,1))>=0
%                 first2(j,:)=[nan, nan, nan];
%             else
%                 first2(i,:)=[nan, nan, nan];
%             end
%         end
%     end
% end
disp( [ 'spots (ch1, ch2): ' num2str(nnz(~isnan(first1(:,1)))) ', ' ...
    num2str(nnz(~isnan(first2(:,1)))) ])

%% Filter out overlapping spots
%criOverlap = 2;
disp('Filter out overlapping spots (too close)')

distanceMatrix = pdist2(first1(:,2:3), first1(:,2:3)); % Compute distance matrix
[i,j] = find(tril(distanceMatrix < criOverlap & distanceMatrix ~= 0)); % Find pairs of rows within criOverlap
first1(unique([i,j]),:) = NaN; % Remove rows

distanceMatrix = pdist2(first2(:,2:3), first2(:,2:3)); % Compute distance matrix
[i,j] = find(tril(distanceMatrix < criOverlap & distanceMatrix ~= 0)); % Find pairs of rows within criOverlap
first2(unique([i,j]),:) = NaN; % Remove rows
% for i=1:cnt1-1
%     for j=i+1:cnt1
%         displace = first1(i,:) - first1(j,:);
%         distance = sqrt(displace(2)^2 + displace(3)^2);
%         if distance < criOverlap
%             first1(i,:)=[nan, nan, nan];
%             first1(j,:)=[nan, nan, nan];
%         end
%     end
% end
% for i=1:cnt2-1
%     for j=i+1:cnt2
%         displace = first2(i,:) - first2(j,:);
%         distance = sqrt(displace(2)^2 + displace(3)^2);
%         if distance < criOverlap
%             first2(j,:)=[nan, nan, nan];
%             first2(i,:)=[nan, nan, nan];
%         end
%     end
% end
disp( [ 'spots (ch1, ch2): ' num2str(nnz(~isnan(first1(:,1)))) ', ' ...
    num2str(nnz(~isnan(first2(:,1)))) ])

%% Correct the chromatic error manually. 
first2(:,2) = first2(:,2) + lateralOffset(1);
first2(:,3) = first2(:,3) + lateralOffset(2);

%% Find the collocalized pairs & time delay ***0 frmae will be handled later

% pairTemp = nan(cnt1, 11); %id, distance, timedelay...
% cntPair = 0;
% for i=1:cnt1
%     distlist = nan(cnt2,1);
%     if ~isnan(first1(i,1))
%         for j=1:cnt2
%             distlist(j) = sqrt((first1(i,2)-first2(j,2))^2+(first1(i,3)-first2(j,3))^2);
%         end
%         [minDist, id] = min(distlist);
%         if minDist<criInter
%             cntPair = cntPair + 1;
%             pairTemp(cntPair,1) = first1(i,1)-first2(id,1);   %timedelay (fr)
%             pairTemp(cntPair,2) = minDist;                    %distance between green and red
%             pairTemp(cntPair,3) = i;                          %id of green
%             pairTemp(cntPair,4) = first1(i,1);                %ref. spot appearnce fr
%             pairTemp(cntPair,5) = first1(i,2);                %ref. spot x
%             pairTemp(cntPair,6) = first1(i,3);                %ref. spot y
%             pairTemp(cntPair,7) = id;                         %id of red
%             pairTemp(cntPair,8) = first2(id,1);               %cf. spot appearnce fr
%             pairTemp(cntPair,9) = first2(id,2);               %cf. spot x
%             pairTemp(cntPair,10) = first2(id,3);              %cf. spot y
%         end
%     end
% end
% pair = pairTemp(1:cntPair,:);


% Inputs: first1 (n1 x 3) matrix, first2 (n2 x 3) matrix, criInter (scalar)
% Outputs: pair (m x 11) matrix or table containing pairs of points that meet the distance criterion

% Find the number of valid rows in first1
valid_rows = ~isnan(first1(:,1));
n1 = sum(valid_rows);

% Preallocate distlist and pairTemp
n2 = size(first2, 1);
max_pairs = n1 * n2;
distlist = nan(n2, 1);
pairTemp = nan(max_pairs, 11);

% Initialize pair counter
cntPair = 0;

% Loop over valid rows of first1
for i = find(valid_rows)'
    % Compute distances between ith point in first1 and all points in first2
    distlist = sqrt(sum((first1(i,2:3) - first2(:,2:3)).^2, 2));

    % Find the index of the closest point in first2
    [minDist, id] = min(distlist);

    % Check if the distance meets the criterion
    if minDist < criInter
        % Increment pair counter
        cntPair = cntPair + 1;

        % Store pair information in pairTemp
        pairTemp(cntPair, 1) = first1(i,1) - first2(id,1); % timedelay (fr)
        pairTemp(cntPair, 2) = minDist; % distance between green and red
        pairTemp(cntPair, 3) = i; % id of green
        pairTemp(cntPair, 4:6) = first1(i,1:3); % ref. spot coordinates
        pairTemp(cntPair, 7) = id; % id of red
        pairTemp(cntPair, 8:10) = first2(id,1:3); % cf. spot coordinates
    end
end

% Extract valid pairs from pairTemp
pair = pairTemp(1:cntPair,:);

% % Convert pair to table (optional)
% pairTable = array2table(pair, 'VariableNames', ...
%     {'timedelay', 'distance', 'green_id', 'green_fr', 'green_x', 'green_y', 'red_id', 'red_fr', 'red_x', 'red_y', 'onDark'});


%% Examine negative delays
rows_negative = (pair(:,1)<0);
pair_negative = pair(rows_negative,:);
cntNegative = size(pair_negative,1);
rows_zero = (pair(:,1)==0);
pair_zero = pair(rows_zero,:);
cntZero = size(pair_zero,1);
rows_positive = (pair(:,1)>0);
pair_positive = pair(rows_positive,:);
cntPositve = size(pair_positive,1);
pair_zeroNpositive = [pair_zero; pair_positive];
str = ['neg/zero/pos delay: ' num2str(cntNegative) '/' num2str(cntZero) '/' num2str(cntPositve)];
disp(str)

%% Load the image stack
if frameToOverlay
    % load the image stack
    cd(pathImgFile)
    stack0=loadtiff(imagefile);

    % Split the Image Channels
    frameToShow = frameToOverlay;
    stack0info = whos('stack0');
    nx = stack0info.size(1);
    ny = stack0info.size(2);
    nSlice = stack0info.size(3);
    frameCnt = nSlice/nChan;
    disp(['Image stack is loaded, frame: ' num2str(frameCnt)])
    datatype = char(stack0info.class);
    multistack = zeros(nx,ny,frameCnt,nChan,datatype);
    for c=1:nChan
        for k=0:frameCnt-1
            multistack(:,:,k+1,c)= stack0(:,:,nChan*k+c);
        end
    end
end


%% Plot results
ReportFigPosition = [100 100 2000 600]; %[left bottom width height]
figHist = figure('OuterPosition', ReportFigPosition, 'Name','Stats');
nRow=1; nCol=4;
tile1 = tiledlayout(1,4,'TileSpacing','Compact','Padding','Compact'); %
titleNote = [path ' | ' trjfile1 ' vs ' trjfile2] ;
t = sgtitle(titleNote); %title(trackfile);
set(t, 'Interpreter','none')



%% Plot results: location of spots
ax1 = nexttile(1);  %delete(ax1);

if frameToOverlay
    frameToShow = frameToOverlay;
    img1 = imadjust(multistack(:,:,frameToShow,RICMchannel));
    imshow(img1); hold on
    %truesize(ax1,[nx ny]); hold on
end
scatter(first1(:,2), first1(:,3), 5, 'o', 'filled', 'g', 'MarkerFaceAlpha', 0.7); hold on
scatter(first2(:,2), first2(:,3), 5, 'o', 'filled', 'r', 'MarkerFaceAlpha', 0.7); hold on
title('Spots | positive (blue) and negative (black) delay');
xlabel(spaceUnit);
pairToShow = pair_zeroNpositive;
xPos = pairToShow(:,5);
yPos = pairToShow(:,6);
scatter(xPos, yPos, 12, 'b', 'LineWidth', 1); hold on
pairToShow = pair_negative;
xPos = pairToShow(:,5);
yPos = pairToShow(:,6);
scatter(xPos, yPos, 12, 'k', 'LineWidth', 1); hold on

% quiver(pair(:,5), pair(:,6), pair(:,9)-pair(:,5), pair(:,10)-pair(:,6), 0, ...
%     'Color','k','LineWidth',1);

% for i=1:cntPair
%     % write time delay for the paired spots
%     delay = pair(i,1);
%     txtoffset = 1;
%     if delay>=0
%         text(pair(i,5)+txtoffset,pair(i,6),num2str(delay),'Color','blue'); hold on
%     else
%         text(pair(i,5)+txtoffset,pair(i,6),num2str(delay),'Color','black'); hold on
%     end
% end

%% Plot results: time points of pair appearance
ax2 = nexttile(2);
histogram(pair_zeroNpositive(:,4), interval:10:150);
title('appearance of paired green spots');
xlabel(['frame, interval = ' num2str(frameInterval,'%0.3f') ' ' char(timeUnit) ]);
ylabel('count');

%% Plot & Fit the time delay (all over FOV)
ax3 = nexttile(3); % time delay
hDelay = histogram(pair(:,1), timeHistEdges, 'FaceColor', [0.5 0.5 0.5], 'edgecolor', 'none');
xline(0, 'k');
%title('time delay (green after red), all over FOV')
xlabel(['frame, interval = ' num2str(frameInterval,'%0.3f') ' ' char(timeUnit) ]);
ylabel('count');
title('time delay, all pairs')
hold on

BinCenter = hDelay.BinEdges(1:end-1)+0.5*hDelay.BinWidth;
idx0 = find(BinCenter == 0);
fittingRange = idx0+1:idx0+TimeDelayFitting;
xData = BinCenter(fittingRange)';
yData = hDelay.Values(fittingRange)';

Exp1decay = fittype('(a-c)*exp(-1*x/b)+c', 'independent', 'x', 'coefficients',{'a','b','c'});
opts1 = fitoptions( 'Method', 'NonlinearLeastSquares' );
[~, tmpIdx]  = min(abs(yData(2:end) - 0.5*yData(1)));
opts1.StartPoint = [yData(1), tmpIdx+1, 0];

try
    [fitresult1, gof1] = fit(xData, yData, Exp1decay, opts1 );
    timeDelayExp1decay = frameInterval*fitresult1.b;

    x = linspace(min(xData), max(xData), 100);
    yfit1 = feval(fitresult1, x);
    h1 = plot(x, yfit1, 'r', 'DisplayName', 'exponential');
    str = ['time delay, all pairs | exp1: ' num2str(timeDelayExp1decay,'%0.2f') ' ' char(timeUnit) ', R^2 = ' num2str(gof1.rsquare,'%0.3f') ];
    title(str)
catch ex
    warning('Time delay fitting failed. Skipping the fitting plot.');
    disp(ex.message);
end    


%% Overlay pairs on a cell iamge
if frameToOverlay
    frameToShow = frameToOverlay;
    % Show the image and spots
    ReportFigPosition = [50 50 1000 1000]; %[left bottom width height]
    figPairOnImg = figure('OuterPosition', ReportFigPosition, 'Name','zero (yellow), positive (green), and negative (red) delay');
    img1 = imadjust(multistack(:,:,frameToShow,RICMchannel));
    imshow(img1);
    truesize(figPairOnImg,[nx ny]); hold on
    pairToShow = pair_zero;
    xPos = pairToShow(:,5);
    yPos = pairToShow(:,6);
    hold on; scatter(xPos, yPos, [], 'y', 'LineWidth', 1); 
    pairToShow = pair_positive;
    xPos = pairToShow(:,5);
    yPos = pairToShow(:,6);
    hold on; scatter(xPos, yPos, [], 'g', 'LineWidth', 1); 
    pairToShow = pair_negative;
    xPos = pairToShow(:,5);
    yPos = pairToShow(:,6);
    hold on; scatter(xPos, yPos, [], 'r', 'LineWidth', 1);

    for i=1:cntPair
        delay = pair(i,1);
        txtoffset = 2;
        if delay>0
            text(pair(i,5)+txtoffset,pair(i,6),num2str(delay),'Color','g'); hold on
        elseif delay<0
            text(pair(i,5)+txtoffset,pair(i,6),num2str(delay),'Color','r'); hold on
        end
    end

    saveas(figPairOnImg,[trjfile1(1:end-4) '_overlaid.fig']);   % save figure

    %% collect pairs only on the dark area on RICM image
    disp('collect pairs on the RICM dark region')
    ricmStack = squeeze(multistack(:,:,:,1));
    maskStack = false(nx,ny,frameCnt);
    for fr=1:frameCnt
        % this setting is not to under-detet cell area !!!
        img1 = ricmStack(:,:,fr);
        se = strel('disk',10); %20
        img2 = imcomplement(img1);
        img2 = imtophat(img2,se);
        img2 = imcomplement(img2);
        %sensitivity = 0.55; %0.55 for THP1
        %T1 = adaptthresh(img1, sensitivity);
        %BW2 = imbinarize(img2, T1);
        BW2 = imbinarize(img2);
        BW2 = imcomplement(BW2);
        MedianFilterMat = [3 3];
        BW2 = medfilt2(BW2,MedianFilterMat);
        se = strel('disk',10); %5
        BW2 = imdilate(BW2,se);
        BW2 = imfill(BW2, 'holes');
        %imshow(BW2) % for parametar optimization
        maskStack(:,:,fr)=BW2;
    end

    Save3DasTIFF(pathImgFile, [filenamehead '_mask'], maskStack);

    pairCnt = size(pair,1);
    onDark = false(pairCnt,1);
    for i = 1:pairCnt
        fr1 = round(pair(i,4));
        xPos = round(pair(i,5));
        yPos = round(pair(i,6));
        fr2 = round(pair(i,8));

        greenOnDark = (maskStack(yPos, xPos, fr1-1) || maskStack(yPos, xPos, fr1) || maskStack(yPos, xPos, fr1+1));
        redOnDark = (maskStack(yPos, xPos, fr2-1) || maskStack(yPos, xPos, fr2) || maskStack(yPos, xPos, fr2+1));

        if greenOnDark && redOnDark
            % !!! note the x, y order !!!
            onDark(i) = true;
            pair(i,11) = true;
        end
    end

    %implay(mastStack) % to check the mask
    %figure; overlay_img = imoverlay(img1, BW1, [1 0 0]); imshow(overlay_img);
    pairOnDark = pair(onDark,:);
    pairNotOnDark = pair(~onDark,:);

    figure(figPairOnImg)
    pairToShow = pairOnDark;
    xPos = pairToShow(:,5);
    yPos = pairToShow(:,6);
    scatter(xPos, yPos, [], "+", 'm', 'LineWidth', 2); hold on

    figure(figHist);
    ax4 = nexttile(4);
    hDelayOnDark = histogram(pairOnDark(:,1), timeHistEdges, 'FaceColor', [0.5 0.5 0.5], 'edgecolor', 'none');
    hold on
    xline(0, 'k');
    title('only in dark')
    xlabel(['frame, interval = ' num2str(frameInterval,'%0.3f') ' ' char(timeUnit) ]);
    ylabel('count');
end

%% Curve fitting for the time delay
if TimeDelayFitting && frameToOverlay
    BinCenter = hDelayOnDark.BinEdges(1:end-1)+0.5*hDelayOnDark.BinWidth;
    idx0 = find(BinCenter == 0);
    fittingRange = idx0+1:idx0+TimeDelayFitting;
    xData = BinCenter(fittingRange)';
    yData = hDelayOnDark.Values(fittingRange)';

    Exp1decay = fittype('(a-c)*exp(-1*x/b)+c', 'independent', 'x', 'coefficients',{'a','b','c'});
    opts1 = fitoptions( 'Method', 'NonlinearLeastSquares' );
    [~, tmpIdx]  = min(abs(yData(2:end) - 0.5*yData(1)));
    opts1.StartPoint = [yData(1), tmpIdx+1, 0];

    try
        [fitresult1, gof1] = fit(xData, yData, Exp1decay, opts1 );
        timeDelayExp1decay = frameInterval*fitresult1.b;
        % LorentzianDist = fittype('a/(1+((x-b)/c)^2)', 'independent', 'x', 'dependent', 'y');
        % opts2 = fitoptions( 'Method', 'NonlinearLeastSquares', 'Lower', [1, 0.01, 0], 'Upper', [100, 100, 100]);
        % opts2.Display = 'Off';
        % [maxValue, maxIndex]= max(yData);
        % [minValue, minIndex]= min(yData);
        % opts2.StartPoint = [maxValue maxIndex abs((maxIndex-minIndex)/2)];
        % [fitresult2, gof2] = fit(xData, yData, LorentzianDist, opts2);
        % timeDelayLorentzian = frameInterval*fitresult2.b;
        figure(figHist);
        nexttile(4)
        hold on

        x = linspace(min(xData), max(xData), 100);
        yfit1 = feval(fitresult1, x);
        h1 = plot(x, yfit1, 'r', 'DisplayName', 'exponential');
        % yfit2 = feval(fitresult2, x);
        % h2 = plot(x, yfit2, 'b', 'DisplayName', 'Lorentzian');
        % str = ['only in dark | exp1: ' num2str(timeDelayExp1decay,'%0.1f') ', Lorentzian: ' num2str(timeDelayLorentzian,'%0.1f') ', ' char(timeUnit)];
        str = ['pairs in dark | exp1: ' num2str(timeDelayExp1decay,'%0.2f') ' ' char(timeUnit) ', R^2 = ' num2str(gof1.rsquare,'%0.3f') ];
        title(str)
        
    catch ex
        warning('Time delay fitting failed. Skipping the fitting plot.');
        disp(ex.message);
    end



end

%% Save results
if ~fTest
    saveas(figHist,[trjfile1(1:end-4) '_pair.fig']);% save figure

    timeDelayAll = frameInterval*pair(:,1);
    writematrix(timeDelayAll, [filenamehead '_timeDelayAll.dat'], 'Delimiter', '\t');

    timeDelayInDark = frameInterval*pairOnDark(:,1);
    writematrix(timeDelayInDark, [filenamehead '_timeDelayInDark.dat'], 'Delimiter', '\t');
    
    % timeDelayHist = [frameInterval*xData yData];
    % saveName = [filenamehead '_timeDelayResult.dat'];
    % dlmwrite(saveName, timeDelayHist, 'delimiter', '\t');
    %writematrix(timeDelayHist, saveName, 'Delimiter', '\t'); 
    %dlmwrite(saveName, timeDelayHist, 'delimiter', '\t', 'precision', '%.5f');



    if frameToOverlay
        save([trjfile1(1:end-4) '_pairOnDark'], 'pair', 'pairOnDark');   % save pair info.
    else
        save([trjfile1(1:end-4) '_pairWholeFOV'],'pair');   % save pair info.
    end

    %  get all variable to save (clear big variables)
    clear 'distanceMatrix' 'ricmStack' 'multistack' 'stack0'
    varData = whos;
    % save all variable except the graphic handles
    saveIndex = cellfun(@isempty, regexp({varData.class}, 'matlab.(graphics|ui)'));
    saveVars = {varData(saveIndex).name};
    save([trjfile1(1:end-4) '_allVariables'], saveVars{:});


end

%% The end of main script
toc(PTS2anaStart)
fclose all;



%% Note





%%%%%%%%%%%%%%%%%%%% functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [tracks, metadata] = LoadTrackMateTracksMJv1(file)
    % MJ 230317
    % Load TrackMate Tracking data (.xml) Using low level functions to compile it to C.
    % 'readstruct' is also not supported by coder... OTL...
    % but xml loading using 'readstruct' is much faster than importTrackMateTracks
    
    %% XML to struct
    s = readstruct(file,'FileType','xml');
    
    %% Load TrackMate meta data
    nTracks = s.nTracksAttribute;
    metadata.spaceUnits = s.spaceUnitsAttribute;
    metadata.timeUnits = s.timeUnitsAttribute;
    metadata.frameInterval = s.frameIntervalAttribute;
    metadata.date = s.generationDateTimeAttribute;
    metadata.source = s.fromAttribute;
    
    %% organize each track
    tracks = cell(nTracks, 1);
    for i = 1 : nTracks
        %nSpots = s.particle(i).nSpotsAttribute;
        detectionNode = s.particle(i).detection;
        t = vertcat(detectionNode(:).tAttribute);
        x = vertcat(detectionNode(:).xAttribute);
        y = vertcat(detectionNode(:).yAttribute);
        z = vertcat(detectionNode(:).zAttribute);
        A = [ t x y z ];
        tracks{i} = A;
    end

end

function [] = Save3DasTIFF(filepath, filenamehead, imgStack3D)
    fullFileName = fullfile(filepath, [filenamehead '.tif']);
    % check if there is a file with the same name. 
    while exist(fullFileName, 'file') == 2
        filenamehead = [filenamehead 'New'];
        fullFileName = fullfile(filepath, [filenamehead '.tif']);
    end

    for fr = 1:size(imgStack3D, 3)
        thisFrame = imgStack3D(:, :, fr);
        imwrite(thisFrame, fullFileName, 'WriteMode', 'append', 'Compression', 'none');
    end
    disp('TIFF stack saved successfully.');
end

